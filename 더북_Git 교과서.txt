

숨겨진 폴더까지 같이 복사하는 명령어
: $ cp -r 원본폴더 복사폴더


작업하는 공간: working
임시 저장 공간: stage
실제 저장 공간: repository

untracked 상태: 워킹 디렉토리에 '새로 생성된 파일'은 모두 '추적되지 않음' 상태이다.
tracked 상태: 'git add 파일 이름' 명령어를 통해 untracked 상태의 파일을 '추적' 상태로 변경.

stage = 임시 영역 : 워킹 디렉터리에서 작업이 끝난 파일을 스테이지로 복사. 커밋 하려는 파일들의 추적 상태 정보들만 기록.
<파일들의 스테이지 상태 확인>
: git status
: git ls-files -- stage

<modified 상태>
파일이 수정되면 modified 상태로 변경되고, 수정된 파일은 스테이지에서 제외된다. git add 명령어를 통해 스테이지 영역에 다시 적용 가능하다.

<unmodified 상태>
tracked 상태이면서 스테이지에 한번도 수정하지 않은 원본 상태 의미.

<status 명령어> : 깃의 상태 메시지를 확인
$ git status ---- 상태 확인
On branch master
No commits yet ---- 커밋이 없다는 메시지
nothing to commit (create/copy files and use "git add" to track) ---- 변경된 내용이 없다는 메시지

파일 관리 목록에서 제외(.gitignore) : 깃에서 관리하지 않는 파일들의 목록을 갖고 있다.
.gitignore파일은 덱스트 에디터를 이용해 간단하게 작성 가능. 저장소의 최상위 티렉터리에 두어야함. 
<.gitignore 파일 표기법>
#: 주석처리.
*: 모든 문자열을 대체.(셸 글로빙(globbing))
!: 제외하지 않을 파일.

ex)
 # DB 접속 파일을 제외함
 dbinfo.php

 # 오브젝트 파일은 제외함
 *.obj

 # 환경 설정 파일은 제외하면 안 됨
 !config.php

<깃에서 디렉터리 표현. 깃은 glob 패턴을 지원하므로, 정규 표현식을 응용해 규칙 작성 가능.>
 # 현재 디렉터리 안에 있는 파일 무시
 /readme.txt

 # /pub/ 디렉터리 안의 모든 것을 무시
 /pub/

 # doc 디렉터리 아래의 모든 .txt 파일 무시
 doc/**/*.txt


깃 저장소 복제
: $ git clone 원격저장소URL 새폴더이름

파일 등록 취소: tracked 상태의 파일 -> untracked 상태로 변경. 삭제(rm)나 리셋(reset) 명령어 사용.
: $ git rm --cached 파일 이름	--- 스테이지의 캐시 목록에서 파일 삭제됨.

* 파일 커밋하지 않고 바로 삭제 : 'rm --cached'명령어
* 한번이라도 커밋 한경우 'reset' 명령어 사용. : 파일이 사제 또는 변화된 것으로 간주.

파일 이름 변경
: $ git mv 파일이름 새파일이름
    => git rm 파일이름 -> git add 새파일이름

<처음 커밋>
커밋(commit) : 의미 있는 변경 작업들을 저장소에 기록하는 동작. : $ git commit
HEAD: 커밋을 가리키는 묵시적 참조 포인터. 즉 최종적인 커밋 작업의 위치 가리킴. 처음 커밋할때는 없음.
스냅샷: HEAD가 가리키는 커밋을 기반으로 사진을 찍고 스테이지 영역과 비교해 새로운 커밋으로 기록.

# 커밋내용으로는 첫째줄에 제목, 다음줄에 상세 내용 작성.

파일 등록과 커밋 동시에: $ git commit -a
커멧과 메시지 작성 동시에: $ git commit -m 메시지

커밋 로그 확인 : $ git log


<두번째 커밋>
#수정한 파일을 커밋 전 마지막 내용으로 되돌리기: $ git checkout -- 수정파일이름#
파일 등록(git add) -> 커밋(git commit)

-am 옵션: 파일 등록과 한 줄짜리 커밋 메시지를 동시에 처리.
  # -am 명령어 사용하기 위해서는 add 명령어 먼저 수행
$ git commit -am "커밋메시지"

커밋 로그 확인 : $ git log


<메시지가 없는 빈 커밋>
커밋은 반드시 커밋 메시지를 같이 작성해야함. 메시지가 없는 커밋 = '빈 커밋'


<세 번째 커밋>
'--allow-empty-message' 옵션 사용
: $ git commit --allow-empty-message -m ""   <- 커밋 메시지를 작성하지 않음.

# 직전 커밋 메시지 수정 : --amend
: git commit --amend


커밋 아이디 : git log의 commit 뒤에 나오는 영문과 숫자. 커밋 아이디는 특징 커밋을 가리키는 절대적 이름, 명시적 참조값.


SHA1: 깃 스테이지 영역은 40자리의 복잡한 hexa 값으로 되어 있는 SHA1 해시키를 생성.
-> 중복되지 않은 고유의 키를 생성.
  =  콘텐츠의 추적과 분산형 저장 관리를 운영하면서 충돌 방지하기 위해 사용.

단축키: SHA1 해시키는 40자리, 16진수로 구성되어 있는 매우 큰 숫자이므로 고유 접두사로 간략하게 사용할 수 있다. => '앞쪽 7자만으로 중복 방지'하며, 전체 키 값 사용할 수 있다.


<커밋 로그>
간략 로그: 첫 번째 줄의 커밋 메시지만 출력.
 $ git log --pretty=short

특정 커밋의 상세 정보 확인: $ git show 커밋ID


특정 파일의 로그: $ git log 파일이름
[log 명령어의 여러 옵션]
 -p 옵션: diff 기능(수정한 라인 비교)을 같이 포함하여 출력할 수 있음.
 --stat 옵션: 히스토리를 출력한다.
 --pretty=online 옵션: 각 커밋을 한 줄로 표시한다.


<diff 명령어>
깃은 커밋을 기준으로 파일들의 수정 이력을 비교해 볼 수 있는 diff 기능 제공.
diff 기능으로 파일의 '수정 및 변경 내역을 쉽게 파악'할 수 있음.
q를 통해 나올 수 있음.

: $ git diff  <-  스테이지 vs 워킹 디렉터리 비교.
# 변경한 파일을 스테이지 영역에 등록한 경우 diff 명령어는 아무 내용 출력하지 않음.

: $ git diff head    <-  head 포인터 입력

diff 내용을 추가하여 커밋: $ git commit -v

[정리]
- 커밋은 깃에서 소스 코드를 관리하는 첫 단추
- 작은 단위로 코드를 수정한 후 커밋 하는 것을 추천.
- 커밋의 수정 부분이 적을수록 검토하기 쉽고, 오류 찾기 쉽다.


5장 서버
서버 저장소 = 원격(remote) 저장소 : 로컬 저장소의 코드를복제한 복사본.
 - 코드를 안전하게 보관 가능, 공유와 협업 가능

깃허브: 깃호스팅 서비스. 

로컬 저장소를 원격 저장소에 연결하는 방법(새로운 저장소 생성, 기존 저장소 연결)
- 새 로컬 저장소 생성해 연결하는법.
$ mkdir gitstudy	 <- 새 폴터 만들기
$ cd gitstudy
$ git init  <- 저장소를 깃으로 초기화

저장소의 소개 페이지 파일을 하나 생성. echo 명령어로 문자열을 파일로 리다이렉션하여 소개 페이지 만듦.
$ echo "#gitstudy" >> README.md  <- 파일 생성

만든 README.md 파일을 '추적 등록'하고 '커밋'함.
$ git add README.md  <- 스테이지에 등록
$ git commit -m "first comit"  <- 커밋


프로토콜: 서버와 통신 하는 방식. 깃은 기본적으로 Local, HTTP, SSH, Git 네 종류의 방식을 지원.
 Local: 로컬 컴퓨터에 원격 저장소를 생성하는 것 의미. NFS(Network File System)등 서버로 이용할때 편리.
	로컬은 간단하게 원격 서버를 구축할 수 있을 뿐 아니라 빠른 동작 가능하나 모든 자료 자신의 컴퓨터에 집중되는 위험 있음.  
	
로컬 저장소를 서버로 이용할 때는 '폴더 경로만 입력'하면 됨.
: $ git remote add 원격저장소별칭 폴더경로

 HTTP: 웹에서 데이터를 주고 받는 프로토콜. 로그인 절차를 통해 접속자를 인증해 처리. 익명 또는 계정을 통한 처리 가능하다.

 SSH: 깃에서 권장하는 프로토콜. 높은 수준의 보안 통신으로 처리해 깃 서버를 좀더 안전하게 운영할 수 있음. 'ssh://계정@주소'와 같이 프로토콜 타입을 지정해야 함. 계정을 생략해 현재 로그인된 사용자로 대체할 수 있음.
SSH 접속을 할 때는 인증서를 만들어 사용하며, 접속시 별도의 로그인 절차 필요 없음. 인증서는 공개피와 개인키로 구분하며, 공개키는 서버에, 개인키는 로컬에 저장.
HTTP와 달리 익명 접속 불가하므로 기업에서 깃 서버를 운영할 때 적합한 프로토콜.

 Git: 깃의 데몬 서비스를 위한 전용 프로토콜 방식. SSH와 유사하지만 인증 시스템 없어 보안에 취약. 잘 사용 안함.


<원격 저장소의 리모트 목록 관리>
remote 명령어 : 현재 연결된 원격 저장소 목록을 확인 할 수 있음.
 $ git remote: 원격 저장소의 이름(별칭)을 출력
 $ git remote -v: 원격 저장소의 별칭 이름과 URL을 확인.
    # 깃은 복수의 원격 저장소를 연결해 사용할 수 있음. remote 저장소가 여러개 있을때는 목록을 모두 출력 하지만, 저장소의 권한 정보까지는 알 수 없음.


주소와 별칭
로컬 저장소에 원격 저장소(서버)를 등록 하려면 '서버 주소'가 필요.
원격 저장소는 '프로토콜 + 도메인 주소' 형태.
로컬에 서버 저장소를 생성할 때는 '폴더 경로' 를 사용.

별칭: 긴 서버 URL 문자열을 별칭으로 만들어 사용.
origin: 대표적으로 사용하는 별칭. 기본적으로 원격 서버와 연결할 때 별칭으로 origin 사용. 목적에 따라 다른이름 사용해도 됨.

별칭은 중복하여 선택할 수 없음.


<원격 저장소에 연결>
: $ git remote add 원격저장소별칭 원격저장소URL
ex). git remote add origin hpps:~~  <- 자신의 깃 서버
git remote -v  <- 원격 저장소 목록 확인

원격 저장소가 연결되면 'fetch와 push 두 주소'를 출력함.
push: 서버로 전송하는 동작.
fetch: 서버에서 가져오는 동작.


[별칭 이름 변경과 정보]
등록된 서버의 별칭 이름 다시 변경
: $ git remote rename 변경전 변경후

remote 명령어는 간략한 원격 저장소 정보만 출력.
원격 저장소의 상세 정보 확인
: $ git remote show 원격저장소별칭
ex) git remote show origin


원격 서버 삭제
로컬 저장소는 복수의 원격 저장소와 연결할 수 있음. 등록된 원격 저장소는 rm 옵션으로 삭제 가능.
 : $ git remote rm 원격저장소별칭

등록된 origin 저장소를 삭제하고, 목록을 다시 확인.
: $ git remote rm origin  <- 원격 저장소 삭제
git remote -v  <- 원격 저장소 목록 확인.


<서버 전송>
push: 원격 저장소로 커밋된 파일들을 업로드 하는 동작.
: $ git push 원격저장소별칭 브랜치이름

<자동으로 내려 받기>

















